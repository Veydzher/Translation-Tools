import re
import os
import time
import json
import msvcrt
import platform
from pathlib import Path

try:
    from lxml import etree as ET # type: ignore
except ImportError:
    import subprocess
    import sys
    print("Module 'lxml' not found. Installing...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "lxml"])
    from lxml import etree as ET # type: ignore

class InvalidFileFormat(BaseException): ...
class UserCancelled(BaseException): ...

APP_NAME = "Android XML to Apple STRINGS Converter"
class XMLtoSTRINGS:
    def __init__(self):
        self.config = Config()
        self.main()
        
    def main(self):
        try:
            self.clear()
            self.print_box([f"{APP_NAME} by veydzh3r", "Github: https://github.com/Veydzher/Translation-Tools"], 6, 2, "center")
            choice = self.choice_input("", {1: "Export strings from .xml", 2: "Import strings from .strings", 3: "Settings", 4: "Exit"})
            
            if choice == 1:
                xml_file_path = self.file_input("existing", "xml")
                
                output_file = self.file_input("new", "strings", "Localizable")
                
                print()
                
                if xml_file_path and output_file:
                    strings = self.get_xml_strings(xml_file_path)
                    if strings:
                        self.export_strings(output_file, strings)
                    else:
                        print("No strings found in XML file!")
            
            elif choice == 2:
                xml_file_path = self.file_input("existing", "xml")
                
                apple_file_path = self.file_input("existing", "strings")
                
                output_file = self.file_input("new", "xml", "strings_edited")
                
                print()
                
                if xml_file_path and apple_file_path and output_file:
                    modified_strings = self.get_apple_strings(apple_file_path)
                    if modified_strings:
                        self.import_strings(xml_file_path, output_file, modified_strings)
                    else:
                        print("No valid strings found in .strings file!")
            
            elif choice == 3:
                self.open_settings()
            
            elif choice == 4:
                print("Exiting the program...")
                exit(0)
            
            print("\nPress any key to exit..."); msvcrt.getch(); self.main()
        
        except FileNotFoundError as e:
            print(str(e)); time.sleep(1); self.clear(); self.main()
        except InvalidFileFormat as e:
            print(str(e)); time.sleep(1); self.clear(); self.main()
        except KeyboardInterrupt:
            print("\n\nProgram interrupted by user."); exit(0)
        except UserCancelled:
            self.main()
        except Exception as e:
            print(f"Unexpected error: {str(e)}\nReport the error to veydzh3r.\nPress any key to exit...")
            msvcrt.getch(); exit(0)
            
    def open_settings(self):
        detailed_export = self.config.get("detailed_export")
        detailed_import = self.config.get("detailed_import")
        
        self.clear()
        self.print_box([APP_NAME, "Settings"], alignment="center")
        choice = self.choice_input("", {1: f"Toogle detailed export output: {detailed_export}", 2: f"Toogle detailed import output: {detailed_import}", 3: "Back"})

        if choice == 1:
            self.config.set("detailed_export", not detailed_export)
        elif choice == 2:
            self.config.set("detailed_import", not detailed_import)
        else:
            self.main()
        
        self.open_settings()
    
    def get_xml_strings(self, file_path: str):
        tree = ET.parse(file_path, parser=None)
        root = tree.getroot()
        strings = {}
        
        for child in root.iter("string"):
            name = child.get("name")
            if name:
                text = child.text
                strings[name] = text
        
        return strings
    
    def export_strings(self, file_path:str, strings:dict, export_none_strings:bool = False):
        try:
            exported_strings_count = 0
            exported_none_strings_count = 0
            skipped_none_strings_count = 0
            
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(f"/* Generated by veydzh3r's {APP_NAME}: https://github.com/Veydzher/Translation-Tools/tree/main/Android */\n")
                for name in sorted(strings):
                    if strings[name] is not None:
                        text = self.quote_unicode(strings[name])
                        f.write(f"\"{name}\" = \"{text}\";\n")
                        exported_strings_count += 1
                    else:
                        if export_none_strings:
                            f.write(f"\"{name}\" = \"\";\n")
                            exported_none_strings_count += 1
                        else:
                            skipped_none_strings_count += 1
        except Exception as e:
            print(f"Export error: {str(e)}")
            return False
        
        filename = os.path.basename(file_path)
        
        detailed_export = self.config.get("detailed_export")
        
        if detailed_export:
            self.print_box([
                f"Total strings: {len(strings)}",
                f"Exported strings: {exported_strings_count}",
                f"Exported empty strings: {exported_none_strings_count}" if exported_none_strings_count else f"Skipped empty strings: {skipped_none_strings_count}",
                f"Strings have been saved to {filename}!"
            ])
        else:
            self.print_box([
                f"Total strings: {len(strings)}",
                f"Exported strings: {exported_strings_count}",
                f"Strings have been saved to {filename}!"
            ])
        
        return True
    
    def get_apple_strings(self, file_path: str):
        try:
            try:
                with open(file_path, "r", encoding="utf-16") as f:
                    content = f.read()
            except UnicodeError:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()
        except Exception as e:
            print(f"Error reading file {file_path}: {e}")
            return {}
        
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        content = re.sub(r'//.*', '', content)
        
        pattern = r'"(.*)"\s*=\s*"(.*)"\s*;'
        matches = re.findall(pattern, content, flags=re.DOTALL)
        
        result = {}
        for key, value in matches:
            unescaped_key = self.unquote_unicode(key)
            unescaped_value = self.unquote_unicode(value)
            result[unescaped_key] = unescaped_value
        
        return result
    
    def import_strings(self, source_file: str, output_file: str, strings: dict):
        try:
            tree = ET.parse(source_file, parser=None)
            root = tree.getroot()
            
            import_strings_count = 0
            success_import_strings = []
            failed_import_strings = []
            
            for str_obj in root.iter("string"):
                obj_name = str_obj.get("name")
                if obj_name in strings and obj_name:
                    old_text = str_obj.text
                    new_text = strings[obj_name]
                    if old_text != new_text and old_text is not None:
                        success_import_strings.append("\tKey: \"{}\"\n\tOld: {}\n\tNew: {}\n".format(obj_name, old_text, new_text))
                        str_obj.text = new_text
                        import_strings_count += 1
                    else:
                        failed_import_strings.append("\tKey: \"{}\"\n\tOld: {}\n\tNew: {}\n".format(obj_name, old_text, new_text))
            
            detailed_import = self.config.get("detailed_import")
            
            if detailed_import:
                if success_import_strings:
                    with open("success_import_strings.txt", "w+", encoding="utf-8") as sf:
                        sf.write("Successfully exported the following strings:\n")
                        for ses in success_import_strings:
                            sf.write("{}\n".format(ses))
                
                if failed_import_strings:
                    with open("failed_import_strings.txt", "w+", encoding="utf-8") as ff:
                        ff.write("Failed to import the following strings:\n")
                        for fis in failed_import_strings:
                            ff.write("{}\n".format(fis))
            
            if import_strings_count != 0:
                tree.write(output_file, encoding="utf-8", xml_declaration=True, pretty_print=True)
                output_file = os.path.basename(output_file)
                self.print_box([
                    f"Total strings: {len(root.xpath('.//string'))}",
                    f"Imported strings: {import_strings_count}",
                    f"Strings have been imported to {output_file}!"
                ])
            
            else:
                print("Found no strings to update!")
        
        except Exception as e:
            print(f"Import error: {e}")
    
    def choice_input(self, msg:str, options:dict[int,str]):
        try:
            if msg:
                print(msg)
            
            for num, string in options.items():
                print("{}. {}".format(num, string))
            
            choice = int(input(">>> "))
            if choice not in options.keys():
                raise ValueError
            return choice
        except ValueError:
            print("Invalid choice! Try again."); time.sleep(1); self.choice_input(msg, options)
    
    def file_input(self, kind: str, extension: str, default: str = ""):
        def esc_input(prompt: str):
            print(prompt, end="", flush=True)
            buffer = ""
            while True:
                ch = msvcrt.getwch()
                if ch == '\r':  # Enter
                    print()
                    return buffer.strip().strip('"') if buffer else ""
                elif ch == '\x1b':  # ESC
                    return None
                elif ch == '\b':  # Backspace
                    if buffer:
                        buffer = buffer[:-1]
                        print("\b \b", end="", flush=True)
                else:
                    buffer += ch
                    print(ch, end="", flush=True)
        
        try:
            file_path = ""
            display_ext = ".{}".format(extension.lower())

            if kind == "new":
                file_path = esc_input(f"Enter a name for {display_ext} output file" + (f" (default: {default}): " if default else ": "))
                
                if file_path is None:
                    raise UserCancelled
                
                if not file_path and default:
                    file_path = default
                
                file_path = file_path + display_ext
                
                if not self.is_valid_windows_filename(os.path.basename(file_path)):
                    raise InvalidFileFormat("Filename contains invalid characters, ends with space/dot, or uses a reserved OS name.")
                
                while True:
                    if os.path.exists(file_path):
                        file = os.path.basename(file_path)
                        file_path = os.path.splitext(file)[0] + " - Copy" + os.path.splitext(file)[1]
                    else:
                        break
            
            elif kind == "existing":
                file_path = esc_input(f"Enter the path to a {display_ext} file: ")
                
                if file_path is None:
                    raise UserCancelled
                if not os.path.exists(file_path):
                    raise FileNotFoundError(f"Specified {display_ext} file not found! Try again.")
                elif not file_path.lower().endswith(display_ext):
                    raise InvalidFileFormat(f"Invalid file format! Should be {display_ext}!")

            return file_path
        
        except (FileNotFoundError, InvalidFileFormat) as e:
            print(str(e))
            time.sleep(1)
            return self.file_input(kind, extension, default)
        except UserCancelled:
            self.main()
    
    def clear(self):
        os.system('cls' if os.name == 'nt' else 'clear')

    def is_valid_windows_filename(self, name):
        invalid_chars = set('<>:"/\\|?*')
        if any(char in name for char in invalid_chars):
            return False
        if name.endswith(' ') or name.endswith('.'):
            return False
        base = os.path.splitext(name)[0].upper()
        reserved_windows_names = [
            "CON", "PRN", "AUX", "NUL",
            "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
            "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"
        ]
        if base in reserved_windows_names:
            return False
        return True

    def print_box(self, lines:list[str], h_padd:int = 4, v_padd:int = 2, alignment:str = "left"):
        """
        Args:
            lines (list[str]): list of strings to be printed.
            h_padd (int, optional): Horizontal Padding. Defaults to 4.
            v_padd (int, optional): Vertical Padding. Defaults to 2.
            alignment (str, optional): Alignment of lines. Avaliable options are left, right and center.
        """
        max_length = max(len(line) for line in lines)
        
        half_h_padd = " " * int(h_padd/2)
        half_v_padd = int(v_padd/2)
        
        top_border = "┌" + "─" * (max_length + h_padd) + "┐"
        bottom_border = "└" + "─" * (max_length + h_padd) + "┘"
        
        print(top_border)
        for _ in range(0, half_v_padd):
            print(f"│{" " * (max_length + h_padd)}│")
        
        for line in lines:
            line = (line.ljust(max_length) if alignment == "left" else line.rjust(max_length) if alignment == "right" else line.center(max_length))
            print(f"│{half_h_padd}{line}{half_h_padd}│")
        
        for _ in range(0, half_v_padd):
            print(f"│{" " * (max_length + h_padd)}│")
        print(bottom_border)

    def quote_unicode(self, s: str):
        if not s:
            return s
        
        if s.startswith('"') and s.endswith('"'):
            s = s[1:-1]
        
        # s = s.replace("\\", "\\\\")  # Backslash must be first
        # s = s.replace("\"", "\\\"")  # Double quote
        # s = s.replace("\'", "\\'")   # Single quote
        s = s.replace("\a", "\\a")   # Bell
        s = s.replace("\b", "\\b")   # Backspace
        s = s.replace("\f", "\\f")   # Form feed
        s = s.replace("\n", "\\n")   # Newline
        s = s.replace("\r", "\\r")   # Carriage return
        s = s.replace("\t", "\\t")   # Tab
        s = s.replace("\v", "\\v")   # Vertical tab
        s = s.replace("\0", "\\0")   # Null character
        
        return s

    def unquote_unicode(self, s: str):
        if not s:
            return s
        
        s = s.replace("\\a", "\a")
        s = s.replace("\\b", "\b")
        s = s.replace("\\f", "\f")
        s = s.replace("\\n", "\n")
        s = s.replace("\\r", "\r")
        s = s.replace("\\t", "\t")
        s = s.replace("\\v", "\v")
        s = s.replace("\\0", "\0")
        # s = s.replace("\\\"", "\"")
        # s = s.replace("\\'", "'")
        # s = s.replace("\\\\", "\\")
        
        if "  " in s or "'" in s or "\n" in s or "\r" in s or "\t" in s or s[0] == " " or s[-1] == " ":
            s = f'"{s}"'
        
        if s[0] == "?":
            s = f"\\{s}"
        
        return s

class Config:
    def __init__(self, config_file = "config.json", config_folder = f"veydzh3r\\{APP_NAME}"):
        self.config_path = self.get_config_path(config_file, config_folder)
        self.config = {}
        self.load()
        
        print(self.config_path)
    
    def get_config_path(self, file, folder):
        if platform.system() == "Windows":
            base_dir = Path(os.getenv("APPDATA", Path.home() / "AppData" / "Roaming"))
        else:
            base_dir = Path.home() / ".config"
        
        app_dir = base_dir / folder
        app_dir.mkdir(parents=True, exist_ok=True)
        
        return app_dir / file
    
    def load(self):
        if self.config_path.exists():
            with open(self.config_path, "r", encoding="utf-8") as f:
                self.config = json.load(f)
        else:
            self.config = { "detailed_export": False, "detailed_import": True }
            self.save()
    
    def save(self):
        with open(self.config_path, "w", encoding="utf-8") as f:
            json.dump(self.config, f, indent=2)
    
    def get(self, key, default = None):
        return self.config.get(key, default)
    
    def set(self, key, value):
        self.config[key] = value
        self.save()

if __name__ == "__main__":
    XMLtoSTRINGS().main()
